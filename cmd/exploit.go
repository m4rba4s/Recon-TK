
package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"time"

	"github.com/fatih/color"
	"github.com/spf13/cobra"
	"recon-toolkit/pkg/exploit"
)

var (
	exploitTimeout    int
	exploitThreads    int
	exploitAggressive bool
	exploitUserAgent  string
	exploitFormat     string
	exploitOutput     string
)

var exploitCmd = &cobra.Command{
	Use:   "exploit",
	Short: "Advanced vulnerability scanner with automated exploit generation",
	Long: `ðŸ”¥ EXPLOIT MODULE - Advanced Vulnerability Scanner

Advanced vulnerability detection with automated exploit and PoC generation:

ðŸŽ¯ VULNERABILITY DETECTION:
  â€¢ SQL Injection with database-specific payloads
  â€¢ Cross-Site Scripting (XSS) - Reflected, Stored, DOM-based
  â€¢ Command Injection with OS-specific payloads  
  â€¢ Server-Side Template Injection (SSTI)
  â€¢ Local/Remote File Inclusion (LFI/RFI)
  â€¢ Path Traversal and Directory Listing
  â€¢ XXE (XML External Entity) Injection
  â€¢ CSRF (Cross-Site Request Forgery)
  â€¢ Buffer Overflow Detection
  â€¢ Authentication Bypass Techniques

ðŸ”§ AUTOMATED EXPLOITATION:
  â€¢ Dynamic payload generation
  â€¢ Multi-vector testing (GET/POST/Headers)
  â€¢ Confidence-based reporting
  â€¢ Python exploit code generation
  â€¢ Proof-of-Concept (PoC) creation
  â€¢ CVSS scoring integration

âš¡ ADVANCED FEATURES:
  â€¢ Aggressive mode for deeper testing
  â€¢ Multi-threaded parallel scanning
  â€¢ Custom payload injection
  â€¢ Response pattern analysis
  â€¢ Error-based detection
  â€¢ Time-based blind testing

Examples:
  recon-toolkit exploit -t https://target.com
  recon-toolkit exploit -t https://target.com --aggressive --threads 20
  recon-toolkit exploit -t https://target.com --format json -o vulns.json
  recon-toolkit exploit -t https://target.com --timeout 30 --user-agent "Custom"`,

	RunE: func(cmd *cobra.Command, args []string) error {
		if target == "" {
			return fmt.Errorf("target is required")
		}

		if !silent {
			color.Red("ðŸ”¥ EXPLOIT MODULE ACTIVATED")
			color.Yellow("Target: %s", target)
			color.Yellow("Threads: %d | Timeout: %ds", exploitThreads, exploitTimeout)
			if exploitAggressive {
				color.Red("ðŸš¨ AGGRESSIVE MODE ENABLED")
			}
		}

		exploitConfig := &exploit.ExploiterConfig{
			Aggressive:      exploitAggressive,
			MaxAttempts:     5,
			Timeout:         time.Duration(exploitTimeout) * time.Second,
			DelayBetween:    time.Second * 2,
			StealthMode:     false,
			LearningMode:    true,
			AutoPrivEsc:     false,
			AutoLateral:     false,
			AutoPersist:     false,
			CleanupAfter:    true,
			MaxSessions:     5,
			AvoidDetection:  false,
		}

		autoExploiter := exploit.NewAutoExploiter("http://localhost:55553/api", exploitConfig)

		if !silent {
			color.Cyan("ðŸ” Starting advanced vulnerability detection...")
		}

		results := autoExploiter.GetResults()
		if len(results) == 0 {
			color.Yellow("No vulnerabilities detected")
			return nil
		}

		err := displayExploitResults(results)
		if err != nil {
			return fmt.Errorf("failed to display results: %w", err)
		}

		if exploitOutput != "" {
			err = saveExploitResults(results[0], exploitFormat, exploitOutput)
			if err != nil {
				color.Red("Failed to save results: %v", err)
			} else if !silent {
				color.Green("ðŸ’¾ Results saved to: %s", exploitOutput)
			}
		}

		return nil
	},
}

func init() {
	rootCmd.AddCommand(exploitCmd)

	exploitCmd.Flags().IntVar(&exploitTimeout, "timeout", 10, "Request timeout in seconds")
	exploitCmd.Flags().IntVar(&exploitThreads, "threads", 10, "Number of concurrent threads")
	exploitCmd.Flags().BoolVar(&exploitAggressive, "aggressive", false, "Enable aggressive testing mode")
	exploitCmd.Flags().StringVar(&exploitUserAgent, "user-agent", "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36", "User agent string")
	exploitCmd.Flags().StringVar(&exploitFormat, "format", "json", "Output format (json, text)")
	exploitCmd.Flags().StringVar(&exploitOutput, "output", "", "Output file path")
}

func displayExploitResults(results []*exploit.ExploitationResult) error {
	if !silent {
		color.Cyan("\nðŸŽ¯ EXPLOITATION RESULTS")
		color.Cyan("=" + string(make([]byte, 50)))
		
		color.White("Total Attempts: %d", len(results))
		
		successCount := 0
		for _, result := range results {
			if result.Success {
				successCount++
			}
		}
		
		color.White("Successful Exploits: %d", successCount)
		
		// Risk summary
		color.Cyan("\nðŸ“Š EXPLOITATION SUMMARY")
		color.Cyan("-" + string(make([]byte, 20)))
		
		for _, result := range results {
			if result.Success {
				color.Red("âœ… SUCCESS: %s on %s:%d", result.Exploit, result.Target, result.Port)
				if result.SessionID != "" {
					color.Green("   Session: %s", result.SessionID)
				}
			} else {
				color.Yellow("âŒ FAILED: %s on %s:%d", result.Exploit, result.Target, result.Port)
			}
		}
	}
	
	return nil
}

func saveExploitResults(result *exploit.ExploitationResult, format, filename string) error {
	switch format {
	case "json":
		data, err := json.MarshalIndent(result, "", "  ")
		if err != nil {
			return err
		}
		return os.WriteFile(filename, data, 0644)
		
	case "text":
		file, err := os.Create(filename)
		if err != nil {
			return err
		}
		defer file.Close()
		
		fmt.Fprintf(file, "EXPLOITATION RESULTS\n")
		fmt.Fprintf(file, "===================\n\n")
		fmt.Fprintf(file, "Target: %s\n", result.Target)
		fmt.Fprintf(file, "Service: %s\n", result.Service)
		fmt.Fprintf(file, "Port: %d\n", result.Port)
		fmt.Fprintf(file, "Success: %t\n\n", result.Success)
		
		if result.Success {
			fmt.Fprintf(file, "EXPLOITATION DETAILS:\n")
			fmt.Fprintf(file, "Vulnerability: %s\n", result.Vulnerability)
			fmt.Fprintf(file, "Exploit: %s\n", result.Exploit)
			fmt.Fprintf(file, "Payload: %s\n", result.Payload)
			if result.SessionID != "" {
				fmt.Fprintf(file, "Session ID: %s\n", result.SessionID)
			}
			fmt.Fprintf(file, "Privileges: %s\n", result.Privileges)
			fmt.Fprintf(file, "OS: %s\n", result.OS)
			fmt.Fprintf(file, "Architecture: %s\n\n", result.Architecture)
		}
		
		if len(result.Credentials) > 0 {
			fmt.Fprintf(file, "CREDENTIALS FOUND:\n")
			for i, cred := range result.Credentials {
				fmt.Fprintf(file, "\n[%d] %s:%s@%s:%d\n", i+1, cred.Username, cred.Password, result.Target, cred.Port)
				fmt.Fprintf(file, "   Service: %s\n", cred.Service)
				fmt.Fprintf(file, "   Valid: %t\n", cred.Valid)
				if cred.Admin {
					fmt.Fprintf(file, "   Admin: true\n")
				}
			}
		}
		
		if len(result.LateralTargets) > 0 {
			fmt.Fprintf(file, "\nLATERAL MOVEMENT TARGETS:\n")
			for i, target := range result.LateralTargets {
				fmt.Fprintf(file, "[%d] %s\n", i+1, target)
			}
		}
		
		return nil
		
	default:
		return fmt.Errorf("unsupported format: %s", format)
	}
}